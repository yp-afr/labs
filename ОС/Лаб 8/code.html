<style type="text/css" scoped="scoped">.slgh,.slgh code,.slgh ul, .slgh ol{margin:0;padding:0;border:0;outline:0;background:none;text-align:left;float:none;vertical-align:baseline;position:static;left:auto;top:auto;right:auto;bottom:auto;height:auto;width:auto;line-height:1.1em;font-family:'Courier New', Courier, monospace;font-weight:normal;font-style:normal;font-size:1em;min-height:inherit;min-height:auto;}.slgh{background:#fff;width:99%;margin:1em 0;padding:1px;position:relative;overflow:auto;overflow-y:hidden;}.slgh ul{list-style:none;margin-left:.5em}.slgh ol{margin-left:3.5em}.slgh .bold {font-weight:bold;}.slgh .italic {font-style:italic;}.slgh .no-wrap li{white-space:pre;}.slgh li{padding-left:.5em;}.slgh li{border-left:3px solid #ccc;color:#666;}.slgh li.alt1{background:#fff;padding-left: 1em;}.slgh li.alt2{background:#F8F8F8;padding-left: 1em;}.slgh .plain, .slgh .plain a{color:#000;}.slgh .comments, .slgh .comments a{color:#008200;}.slgh .string, .slgh .string a{color:blue;}.slgh .keyword{color:#069;font-weight:bold;}.slgh .preprocessor {color:gray;}.slgh .variable{color:#a70;}.slgh .value{color:#090;}.slgh .functions{color:#ff1493;}.slgh .constants{color:#0066CC;}.slgh .script{background:yellow;}.slgh .color1,.slgh .color1 a{color:#808080;}.slgh .color2,.slgh .color2 a{color:#ff1493;}.slgh .color3,.slgh .color3 a{color:red;}.slghcr{margin:-.5em 1.2em}.slghcr a{color:#aaa;background:#fff;text-decoration:none;border-bottom:1px dotted #aaa;font-size:.6em;font-family:arial}</style><div id="hler_75723" class="slgh"><ol class="lines no-wrap"><li class="alt1"><code class="preprocessor">#include &lt;stdio.h&gt;</code></li><li class="alt2"><code class="preprocessor">#include &lt;stdlib.h&gt;</code></li><li class="alt1"><code class="preprocessor">#include &lt;pthread.h&gt;</code></li><li class="alt2"><code class="preprocessor">#include &lt;semaphore.h&gt;</code></li><li class="alt1"><code class="preprocessor">#include &lt;unistd.h&gt;</code></li><li class="alt2">&nbsp;</li><li class="alt1"><code class="plain">sem_t </code><code class="keyword">lock</code><code class="plain">;</code></li><li class="alt2"><code class="plain">sem_t empty; </code></li><li class="alt1"><code class="plain">sem_t full;</code></li><li class="alt2"><code class="keyword">int</code> <code class="plain">buffer[5];</code></li><li class="alt1">&nbsp;</li><li class="alt2"><code class="keyword">int</code> <code class="keyword">in</code> <code class="plain">= 0, </code><code class="keyword">out</code> <code class="plain">= 0;</code></li><li class="alt1">&nbsp;</li><li class="alt2"><code class="plain">pthread_t consumers[4];</code></li><li class="alt1"><code class="plain">pthread_t producers[4];</code></li><li class="alt2">&nbsp;</li><li class="alt1">&nbsp;</li><li class="alt2"><code class="keyword">void</code><code class="plain">* producer(</code><code class="keyword">void</code><code class="plain">* arg){</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">srand(time(NULL));</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">int</code> <code class="plain">n = *((</code><code class="keyword">int</code> <code class="plain">*)arg);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">while</code><code class="plain">(1)</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">{</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">int</code> <code class="plain">item = rand()%1000;</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_wait(&amp;empty);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_wait(&amp;</code><code class="keyword">lock</code><code class="plain">); </code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">buffer[</code><code class="keyword">in</code><code class="plain">] = item;</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">printf(</code><code class="string">"Producer %d: produced item %d\n"</code><code class="plain">, n,buffer[</code><code class="keyword">in</code><code class="plain">]);</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">in</code> <code class="plain">= (</code><code class="keyword">in</code><code class="plain">+1)%5;</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_post(&amp;</code><code class="keyword">lock</code><code class="plain">); </code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_post(&amp;full);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sleep(rand()%3);</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">}</code></li><li class="alt1"><code class="plain">}</code></li><li class="alt2">&nbsp;</li><li class="alt1"><code class="keyword">void</code><code class="plain">* consumer(</code><code class="keyword">void</code> <code class="plain">* arg) {</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">int</code> <code class="plain">n = *((</code><code class="keyword">int</code> <code class="plain">*)arg);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">while</code><code class="plain">(1)</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">{</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_wait(&amp;full);</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_wait(&amp;</code><code class="keyword">lock</code><code class="plain">);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">int</code> <code class="plain">item = buffer[</code><code class="keyword">out</code><code class="plain">];</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">printf(</code><code class="string">"Consumer %d: consumed item %d\n"</code><code class="plain">,n,item);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">out</code> <code class="plain">= (</code><code class="keyword">out</code><code class="plain">+1)%5;</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_post(&amp;</code><code class="keyword">lock</code><code class="plain">);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_post(&amp;empty); </code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sleep(rand()%3);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">}</code></li><li class="alt2"><code class="plain">}</code></li><li class="alt1">&nbsp;</li><li class="alt2"><code class="keyword">int</code> <code class="plain">main() {</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">srand(time(NULL));</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_init(&amp;empty,0,5);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_init(&amp;</code><code class="keyword">lock</code><code class="plain">, 0, 1);</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">sem_init(&amp;full, 0, 0);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">for</code> <code class="plain">(</code><code class="keyword">int</code> <code class="plain">i = 0; i &lt; 4; i++)</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">{</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">pthread_create(&amp;producers[i], NULL, producer,(</code><code class="keyword">void</code><code class="plain">*) &amp;i);</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">usleep(15);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">}</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">for</code> <code class="plain">(</code><code class="keyword">int</code> <code class="plain">i =0; i &lt; 4; i++)</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">{</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">pthread_create(&amp;consumers[i], NULL, consumer,(</code><code class="keyword">void</code><code class="plain">*) &amp;i);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">usleep(15);</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">}</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">for</code> <code class="plain">(</code><code class="keyword">int</code> <code class="plain">i = 0; i &lt; 4; i++) {</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">pthread_join(producers[i], NULL);</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">}</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">for</code> <code class="plain">(</code><code class="keyword">int</code> <code class="plain">i =0; i &lt; 4; i++) {</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">pthread_join(consumers[i], NULL);</code></li><li class="alt2">&nbsp;&nbsp;&nbsp;&nbsp;<code class="plain">}</code></li><li class="alt1">&nbsp;&nbsp;&nbsp;&nbsp;<code class="keyword">return</code> <code class="plain">0;</code></li><li class="alt2"><code class="plain">}</code></li></ol></div><div class="slghcr">Подсветка програмного кода</div>
